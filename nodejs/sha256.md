# encriptar
```js 

const {createHmac} =  require('node:crypto');

const secret = 'abcdefg';
const hash = createHmac('sha256', secret)
               .update('que no te atañe')
               .digest('hex');
console.log(hash);
```


# desencriptar
Para desencriptar el mensaje en Node.js usando la función HMAC que proporcionaste, necesitamos seguir estos pasos:

### Pensamiento paso a paso:

1. Primero, necesitamos entender que la función HMAC que proporcionaste es una función de hash uno-way y no puede ser "desencriptada" en el sentido tradicional.

2. Lo que podemos hacer es verificar si un mensaje dado produce el mismo hash que el original.

3. Necesitaremos la misma clave secreta que se usó para crear el hash original.

4. Podemos usar la función `crypto.timingSafeEqual()` para comparar los hashes de manera segura.

### Puntos clave a considerar:

- HMAC es una función de hash uno-way y no puede ser "desencriptada".
- Necesitamos la clave secreta original para verificar el mensaje.
- Usaremos `crypto.createHmac()` para recrear el hash del mensaje.
- Utilizaremos `crypto.timingSafeEqual()` para comparar los hashes de manera segura.

### Implementación del código:

```javascript
const { createHmac } = require('node:crypto');

function verifyMessage(message, secret) {
  // Crear un nuevo objeto Hmac con la misma clave que se usó originalmente
  const hmac = createHmac('sha256', secret);
  
  // Actualizar el objeto Hmac con el mensaje
  hmac.update(message);
  
  // Obtener el hash del mensaje
  const hash = hmac.digest('hex');
  
  // Comparar el hash del mensaje con el hash original
  return crypto.timingSafeEqual(Buffer.from(hash), Buffer.from(message));
}

// Ejemplo de uso
const secret = 'abcdefg';
const message = 'que no te atañe';

console.log(verifyMessage(message, secret)); // true
```

### Resumen y mejores prácticas:

En este código, hemos creado una función `verifyMessage` que toma un mensaje y la clave secreta como entrada. La función recrea el HMAC usando la misma clave secreta y compara el resultado con el mensaje original utilizando `crypto.timingSafeEqual()`.

Esta implementación sigue las siguientes mejores prácticas:

1. Usa `crypto.createHmac()` para crear un objeto Hmac correcto.
2. Utiliza `update()` para agregar datos al objeto Hmac.
3. Obtiene el hash usando `digest()`.
4. Compara los hashes de manera segura con `crypto.timingSafeEqual()`.

Es importante recordar que esta función no "desencripta" el mensaje original, sino que verifica si el mensaje dado produce el mismo hash que se esperaba. Esto es útil para verificar la integridad y autenticidad de los mensajes, pero no para recuperar el contenido original del mensaje.

